The log parser helps you transform the irregular logs into a structured form. WhaTap Log Monitoring provides two types of parsers.

- **GROK parser**: The logs collected in arbitrary forms are parsed using regular expressions and GROK syntax.

- **JSON parser**: The logs collected in the JSON form are parsed.

:::note

**Common precautions**

- If multiple parsers are registered in the same category, only the first matching parser is applied.

- **WhaTap has the role to disable the parsers that may affect the stability of the WhaTap service.**

:::

## GROK parser{#grok-parser-detail}

If the logs are collected in an irregular form, you can use the GROK parser to parse them. GROK syntax provides named regular expressions, allowing you to use regular expressions more easily. 

See the following video guide for more information about the GROK parser pattern registration.

{@youtube: skgg5KOFGpI}

### Starting GROK {#grok-starting}

GROK provides two types of syntaxes.

1. `%{SYNTAX:SEMANTIC}`: Syntax provided in the GROK library. Using the **named regular expressions**, you can extract tags. For usage examples, see [the following](#syntax-semantic-usage).

   - **SYNTAX**: Specify the named regular expressions provided by GROK.

   - **SEMANTIC**:  Specify the name for the matched value.

   :::note

   **named regular expressions**

   The syntax is provided by GROK. This function provided by GROK allows you to assign names to complex regular expressions.

   | name     | regular expression                                     |
   | -------- | ------------------------------------------------------ |
   | WORD     | `\b\w+\b`                                              |
   | SPACE    | `\s*`                                                  |
   | NOTSPACE | `\S+`                                                  |
   | UUID     | `[A-Fa-f0-9]{8}-(?:[A-Fa-f0-9]{4}-){3}[A-Fa-f0-9]{12}` |

   To see all named regular expressions provided by WhaTap, see the following [link](https://github.com/whatap/java-grok/blob/master/src/main/resources/patterns/patterns).

   :::

2. `(?<SEMANTIC>REGX)`: The **named capturing group** syntax for regular expressions. You can use regular expressions to extract tags according to the user's intent. For usage examples, see [the following](#semantic-regx).

   - **SEMANTIC**: Specify the name for matched values.

   - **REGX**: Enter regular expressions for matching.

   :::note

   **named capturing group**

   It is the syntax provided by regular expressions. 

   - capturing group: This indicates the function to bundle multiple tokens into one as a single matching unit.

   - named capturing group: Name assigned to the capturing group.  

   - Let's look at the string matching example. dev@whatap.io

     > - Example 1 `(\w+)@(\w+\.\w+)`
     > - Example 2: When the entire email is matched and the username and domain are matched additionally, `(?<username>\w+)@(?<domain>\w+\.\w+)`

   :::

#### `%{SYNTAX:SEMANTIC}` Usage example{#syntax-semantic-usage}

The following is an example that uses the `%{SYNTAX:SEMANTIC}` syntax.

```text title='Sample log'
[2023-08-08 02:02:30,101 GMT][INFO ][i.w.y.l.c.LogSinkDexScheduleThread.realProcess(159)] 8 VirtualLog 20230808 02:01:00.000 {area=4, city=5} 56ms
```

You can look at the sample log to infer what each word means. When replacing each part with semantic words, it can be expressed as follows: 

```text title='semantic replace'
[date][logLevel][caller] projectCode logCategiry dexBuildStartTime {area=areaEnum, city=cityEnum} dexBuildElapsed
```

Any semantic word can be replaced with a regular expression. The GROK parser allows you to use the predefined named regular expressions. `TIMESTAMP_ISO8601`, `LOGLEVEL`, and `DATA` used here are named regular expressions provided by GROK. These values are matched after replacing each of them with the following regular expression. 

- name: `TIMESTAMP_ISO8601` 

  - regular expression: `%{YEAR}-%{MONTHNUM}-%{MONTHDAY}[T ]%{HOUR}:?%{MINUTE}(?::?%{SECOND})?%{ISO8601_TIMEZONE}?`

- name: `LOGLEVEL`

  - regular expression: `LOGLEVEL ([Aa]lert|ALERT|[Tt]race|TRACE|[Dd]ebug|DEBUG|[Nn]otice|NOTICE|[Ii]nfo|INFO|[Ww]arn?(?:ing)?|WARN?(?:ING)?|[Ee]rr?(?:or)?|ERR?(?:OR)?|[Cc]rit?(?:ical)?|CRIT?(?:ICAL)?|[Ff]atal|FATAL|[Ss]evere|SEVERE|EMERG(?:ENCY)?|[Ee]merg(?:ency)?)`

- name: `DATA`

  - regular expression: `.*?`

```text title='GROK parsing pattern'
\[%{TIMESTAMP_ISO8601:date}\sGMT\]\[%{LOGLEVEL:level}\s\]\[%{DATA:caller}\]
```

If you parse with the above syntax, you can extract tags as follows. In this way, GROK's `%{SYNTAX:SEMANTIC}` syntax helps you apply complex and long regular expressions easily and concisely.

```text title='Tag extraction'
- date : 2023-08-08 02:02:30,101
- caller : i.w.y.l.c.LogSinkDexScheduleThread.realProcess(159)
- level : LEVEL
```

#### `(?<SEMANTIC>REGX)` Usage example{#semantic-regx}

The parts that do not match with the named regular expressions can be parsed using the `(?<SEMANTIC>REGX)` pattern. In the [sample log](#syntax-semantic-usage) above, the parts that cannot be parsed with the `%{SYNTAX:SEMANTIC}` syntax are as follows.

```text title='Unparsed area'
8 VirtualLog 20230808 02:01:00.000 {area=4, city=5} 56ms
```

When replacing each part of the log with semantic words, it can be expressed as follows.

```text title='semantic replace'
projectCode logCategiry dexBuildStartTime {area=areaEnum, city=cityEnum} dexBuildElapsed
```

These irregularly strings can be parsed using the `(?<SEMANTIC>REGX)` syntax. 

##### Regular expressions that match for each sample log parsing keyword

| Parsing keyword       | `(?<SEMANTIC>REGX)`                                     |
| --------------------- | ------------------------------------------------------- |
| 8                     | `(?<projectCode>\d)`                                    |
| VirtualLog            | `(?<logCategory>\w*)`                                   |
| 20230808 02:01:00.000 | `(?<dexBuildStartTime>\d{8}\s\d{2}:\d{2}:\d{2}\.\d{3})` |
| area=4                | `area=(?<areaEnum>\d)`                                  |
| city=5                | `city=(?<cityEnum>\d)`                                  |
| 56ms                  | `(?<dexBuildElapsed>\d{2})ms`                           |

<details>
<summary><b>Basic regular expression syntax</b></summary>

| Syntax rule      | Meaning                                                       | Alias          |
| ---------------- | ------------------------------------------------------------- | -------------- |
| `?`              | 0 or 1                                                        | -              |
| `+`              | 1 or more                                                     | -              |
| `*`              | 0 or more                                                     | -              |
| `a{5}`           | exactly 5                                                     | -              |
| `\w`             | word character                                                | `[a-zA-Z_0-9]` |
| `\s`             | white space                                                   | -              |
| `.`              | any character except newline                                  |                |
| `[abc]`          | any of                                                        | -              |
| `[^abc]`         | not a,b, or c                                                 | -              |
| `[a-z]`          | character between a and z                                     | -              |
| `[1-3[7-9]]`     | union (combining two or more character classes)               | -              |
| `[1-6&&[3-9]]`   | intersection                                                  | -              |
| `[0-9&&[^2468]]` | subtraction                                                   | -              |
| `a{2,}`          | 2 or more                                                     | -              |
| `a{1,3}`         | between 1 and 3                                               | -              |
| `a+?`            | match as few as possible                                      | -              |
| `{2,3}?`         | match as few as possible                                      | -              |
| `(abc)`          | capturing group (processes multiple strings as a single unit) | -              |
| `\d`             | digit                                                         | `[0-9]`        |
| `\D`             | non-digit                                                     | `[^0-9]`       |
| `\W`             | non-word character                                            | -              |
| `\S`             | non-white space                                               | -              |

</details>

By connecting the parsed keywords with space (`\s`) and special character escapes (`\{`, `\,`, `\}`), you can apply the pattern as follows.

```text title='GROK parsing pattern'
(?<projectCode>\d)\s(?<logCategory>\w*)\s(?<dexBuildStartTime>\d{8}\s\d{2}:\d{2}:\d{2}\.\d{3})\s\{area=(?<areaEnum>\d),\scity=(?<cityEnum>\d)\}\s(?<dexBuildElapsed>\d{2})ms
```

If you parse with the above syntax, you can extract tags as follows.

```text title='Tag extraction'
- projectCode : 8
- logCategory : VirtualLog
- dexBuildStartTime : 20230808 02:01:00.000
- areaEnum : 4
- cityEnum : 5 
- dexBuildElapsed : 56
```

### Applying GROK {#grok-applying}

**_Log setting_** > **_Log primary parser setting_**

1. To apply the GROK pattern parser, go to the **_Log primary parser setting_** tab in **_Log setting_**.

   <ImgLang img='log-1st-parser-list.png' desc='Log parser lists'/>

2. Select **_+ Add_** and then select the **_GROK_** parser in the **_Parser_** field.

   <ImgLang img='log-1st-grok.png' desc='Registering the Grok pattern parser'/>

3. Enter values for **_Category_**, **_Log detection condition_**, and **_Pattern_**. The components of the **_Add Parser_** window are as follows: 

   - **_Category_** 

     Select a log category. **_Category_** is required.

   - **_Log detection condition_** 

     - Only the logs that meet the conditions are applied to the parser.

     - Select or enter values for **_Search key_** and **_Search value_**.

     - **_Log detection conditions_** are applied before all parsers are run. Accordingly, you cannot use the **_tags_** that have been added for the parser.

   - **_Pattern_**

     Specify the GROK pattern. It is required.

4. Select **_Add_** to register a parser. 

:::note

- In the log parser list, you can change the **_priority_** or **_enable_**, **_edit_**, or **_delete_** the parser. 

- Before registering a parser, you can check whether the pattern to register is normal through **_simulation_**. 

:::

:::note

**GROK parser precautions**

- GROK parser supports two patterns: `%{SYNTAX:SEMANTIC}` and `%{SYNTAX:SEMANTIC}`.

- When using the `%{SYNTAX:SEMANTIC}` pattern, `SEMANTIC` must be entered.

- When using the `%{SYNTAX:SEMANTIC}` pattern, `SEMANTIC` must be unique in a parser.

- When using the `(?<SEMANTIC>REGX)` pattern, `SEMANTIC` can only contain characters (a-z, A-Z), numbers (0-9), and specified special characters (`.`, `_`, `-`).

- `SEMANTIC` must start with a character (a-z, A-Z).

- `SEMANTIC` must end with a character (a-z, A-Z) or number (0-9).

:::

### Simulation{#grok-simulation}

You can check the parsed result in advance by entering **_log_** and **_pattern_** in the **_Parser simulation_** window. 

> **_Log_** example: `[2023-08-08 02:02:30,101 GMT][INFO ][i.w.y.l.c.LogSinkDexScheduleThread.realProcess(159)] 8 VirtualLog 20230808 02:01:00.000 {area=4, city=5} 56ms`
>
> **_Pattern_** example: `\[%{TIMESTAMP_ISO8601:date}\sGMT\]\[%{LOGLEVEL:level}\s\]\[%{DATA:caller}\]\s(?<projectCode>\d)\s(?<logCategory>\w*)\s(?<dexBuildStartTime>\d{8}\s\d{2}:\d{2}:\d{2}\.\d{3})\s\{area=(?<areaEnum>\d),\scity=(?<cityEnum>\d)\}\s(?<dexBuildElapsed>\d{2})ms`

1. In the **_Parser addition_** window, select **_Simulation_**. 

2. In the **_Parser simulation_** window, enter values for **_Log_** and **_Pattern_**. 

3. Select **_Simulation_**. You can check the **_simulation result_** as follows:

   <ImgLang img='log-grok-parser-simulation.png' desc='GROK parser simulation'/>

## JSON parser{#json-parser-detail}

If logs are collected in JSON format, they can be easily parsed using the JSON parser.

### Applying the JSON {#json-applying}

**_Log setting_** > **_Log primary parser setting_**

1. To apply the JSON pattern parser, go to the **_Log primary parser setting_** tab in **_Log setting_**.

   <ImgLang img='log-1st-parser-list.png' desc='Log parser lists'/>

2. Select **_+ Add_** and then select the **_JSON_** parser in the **_Parser_** field.

   <ImgLang img='log-1st-json.png' desc='Register json parser pattern'/>

3. Enter values for **_Category_**, **_Log detection condition_**, and **_Pattern_**. The components of the **_Add Parser_** window are as follows: 

   - **_Category_**

     Select a log category. **_Category_** is required.

   - **_Log detection condition_**

     - Only the logs that meet the conditions are applied to the parser.

     - Select or enter values for **_Search key_** and **_Search value_**.

     - **_Log detection conditions_** are applied before all parsers are run. Accordingly, you cannot use the **_tags_** that have been added for the parser.

   - **_Pattern_**

     - **_Prefix_**

       Specify the position where the JSON format begins in the log. If the entire log is in JSON format, set an empty value.

     - **_Postfix_**

       Specify the position where the JSON format ends in the log. If the entire log is in JSON format, set an empty value.

     - **_Ignore_**

       Specify the key for which tags are not created during JSON formatting.

     - Example of JSON pattern

       ```javascript title='Example'
       2023-08-08 02:43:28,615 -- {"host":"10.21.3.24","method":"POST","status":"200","url":"http://devote.whatap.io/yard/api/flush"} --
       ```

       In the example log, if **_Prefix_** and **_Postfix_** are specified as `--` and **_Ignore_** is specified as `--`, Only 3 **_tags_** (`host`, `method`, `status`) are created.

4. Select **_Add_** to register a parser. 

:::note

- In the log parser list, you can change the **_priority_** or **_enable_**, **_edit_**, or **_delete_** the parser. 

- Before registering a parser, you can check whether the pattern to register is normal through **_simulation_**. It is the same as the GROK parser registration simulation process. See [the following](#grok-simulation).

:::

### Example of using JSON format

```javascript title='Sample log'
{"host":"10.21.3.24","method":"POST","status":"200","url":"http://devote.whatap.io/yard/api/flush"}
```

If the above sample log has been collected, select the **_JSON_** parser in the **_Add Parser_** window. Without having to write a complex parsing logic, you can extract the **_tags_** for log analysis as follows:

```javascript title='Tag extraction'
- host : 10.21.3.24
- method : POST
- status : 200
- url : http://dev.whatap.io/yard/api/flush
```

### Usage example when configuring part of the JSON format

```javascript title='Some JSON format sample log'
2023-08-08 02:43:28,615 -- {"host":"10.21.3.24","method":"POST","status":"200","url":"http://devote.whatap.io/yard/api/flush"} --
```

If part of the log is in JSON format as in the example, specify **_Prefix_** and **_Postfix_**. WhaTap log monitoring recognizes and parses the area between **_Prefix_** and **_Postfix_** in JSON format.

```javascript title='Tag extraction'
- host : 10.21.3.24
- method : POST
- status : 200
- url : http://dev.whatap.io/yard/api/flush
```
