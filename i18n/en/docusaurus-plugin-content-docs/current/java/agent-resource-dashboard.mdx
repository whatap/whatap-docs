---
id: agent-resource-dashboard
title: Agent-specific resource dashboard
description: It guides you to the agent-specific resource dashboard.
keywords:
  - Java
  - Dashboard
  - Application
---

Home &gt; <Cmdname sid="side_dashboard" className="uitext" /> &gt; <Cmdname sid="side_agentResourceDashboard" className="uitext" />

:::note 

**Requirements**

The WhaTap Java agent 2.2.39 or later is required. 

:::

The <Cmdname sid="side_agentResourceDashboard" className="uitext" /> menu monitors key metrics such as memory, transactions, and threads for individual Java agents in real time, and displays data up to 3 hours ago. This allows you to see changes in memory usage, active transactions, and executing threads, and analyze the root causes of resource issues.

<ImgLang img="apm-java-agent-resource-dashboard.png" desc="Agent Resource Dashboard" />

## Basic screen

<Cmdname sid="side_agentResourceDashboard" className="uitext" /> allows you to check the memory pool status and related metric change trend of the running agent at a glance. Real-time Java memory area and key metrics you can check on the dashboard are as follows.

### Widget guide

#### Real-time Java memory widget

You can check the status of the JVM main memory pool through the <Cmdname sid="TTL09121" className="uitext" /> widget in real time. Each Java memory area chart displays the memory amount (in MB) and percentage (in %) in use.

- ***Metaspace***

  It is the area where class metadata is stored. 

- ***CodeHeap non-profiled nmethod***, ***CodeHeap profiled nmethod***, ***CodeHeap non-nmethods***

  This area stores the machine code generated by the JIT (Just-In-Time) compiler. ***CodeHeap non-profiled nmethod***, ***CodeHeap profiled nmethod***, and ***CodeHeap non-nmethods*** store each compiled code according to the purpose.

- ***G1 Survivor Space***

  This is the area where the objects survived in G1 GC are temporarily stored.

- ***G1 Eden Space***

  This is the area where newly created objects are allocated first.

- ***G1 Old Gen***

  This is the area where the objects survived through Young GC are moved. As memory increases, you can check if the leak is centered around Old Gen.

- ***Compressed Class Space***

  This area compresses and stores class-related pointers and is managed separately from the Metaspace.

:::note 

- ![Individual equalizer icon](/img/ic-equalizer-chart.svg) Individual chart: Displays each metric as a separate bar, allowing you to clearly compare maximum values ​​for each metric. 

- ![Integrated equalizer icon](/img/ic-bar-chart.svg) Integrated chart: Relative sizes for each metric compared to the whole are displayed at a glance.

- ![Donut chart icon](/img/ic-pie-chart.svg) Donut chart: The proportions for each metric can be checked by expressing the whole as circular proportions. 

- ![Multi-line chart icon](/img/ic-multiline-chart2.svg) Multi-line chart: The trends for all metrics can be checked. 

:::

#### Widget for key metrics

<Columns>
<Column className="text--left width--60">

- ***Memory***

  It displays the total memory utilization (%). It is the total usage that synthesizes internal configurations such as Eden, Old Gen, and Metaspace.

- ***CpuTime***

  The CPU time that the JVM spent executing application code is represented in milliseconds (ms). 

- ***GCCount***, ***GCOldgenCount***

  ***GCCount*** collects only the number of GCs that occurred within a specific period, and ***GCOldgenCount*** collects only the number of GCs targeting the Old area separately.

- ***GCTime***

  The time taken for garbage collection is represented in ms. 

</Column>
<Column className="text--left">

- ***Cpu***

  The CPU utilization (%) of the JVM process is displayed.

- ***TPS***

  The number of processed transactions per second is displayed. 

- ***FileDescriptor***

  It displays the number of file descriptors in use, such as open files or sockets.

- ***ObjectPendingFinalizationCount***

  It displays the number of objects that remain in `finalize()` state that the GC has to process. 

</Column>
</Columns>

### Real-time inquiry

When viewing in real time, you can check the <Cmdname sid="TTL09459" className="uitext" /> panel through the <Cmdname sid="heap_histogram" className="uitext" />, <Cmdname sid="active_transaction" className="uitext" />, and <Cmdname sid="BTN09457" className="uitext" /> buttons on the upper right. 

<ImgLang img="apm-java-agent-resource-dashboard-resource.png" desc="Agent Resource Dashboard Realtime" />

#### <Cmdname sid="heap_histogram" className="uitext" />

In the <Cmdname sid="heap_histogram" className="uitext" /> tab, you can analyze the heap memory resident Java class information and view the top 100 classes that occupy the most memory. If a class occupies excessive amount of memory, you may suspect a memory leak.

#### <Cmdname sid="active_transaction" className="uitext" />

You can view a list of running transactions in the <Cmdname sid="active_transaction" className="uitext" /> tab. You can check the detailed information such as start time, transaction elapsed time, and SQL/HTTP calls. You can find bottlenecks by checking if specific transactions take a long time or use a lot of resources.

#### <Cmdname sid="BTN09457" className="uitext" />

In the <Cmdname sid="BTN09457" className="uitext" /> tab, you can check the list of threads in runnable state within the JVM in real time. It is useful to determine which thread is causing issues upon a high CPU usage or delayed response.

### Historical inquiry

You can use the time selector to select a specific past point and check the resource status at that time point. You can query the resource status up to 3 hours ago and analyze transactions, SQLs, and HTTP calls that occurred at that time. This allows for effectively tracing of the root cause of a sudden spike in CPU or memory usage or a sharp drop in TPS.

<Columns>
<Column className="text--left width--40">
<ImgLang img="apm-java-agent-resource-dashboard-history.png" desc="History Data sc" />
</Column>
<Column className="text--left width--60">
When viewing a past time point, you can view the <UI>Top 30 Statistics</UI> panel where you can check the top 30 statistical data by clicking the <Cmdname sid="transaction" className="uitext" />, <Cmdname sid="statistics_sql" className="uitext" />, and <Cmdname sid="BTN09458" className="uitext" /> buttons on the upper right. 
</Column>
</Columns>

<ImgLang img="apm-java-agent-resource-dashboard-stat.png" desc="Agent Resource Dashboard History" />

#### <Cmdname sid="transaction_statistics" className="uitext" />

In the <Cmdname sid="transaction" className="uitext" /> tab, you can sort the transactions performed at a specific time point by conditions such as response time and execution count, and view the top 30 lists. You can check the items with long response times or high execution counts first.

:::note 

**<Cmdname sid="TTL06975" /> query settings**

If the <Cmdname sid="TTL06975" className="uitext" /> entry is not displayed in the transaction statistics of a past time point, check whether the following option is enabled. However, this option may have a performance impact in the applications with a high average TPS, so it is recommended to apply it only in the **environment with an average TPS of 300 or less**.

- **trace_malloc_enabled** <span class='type'>Boolean</span>

  Default `false`

  It collects average allocated memory per transaction.

:::

#### <Cmdname sid="statistics_sql" className="uitext" />

In the <UI>SQL</UI> tab, you can view the top 30 lists of SQL queries executed at a specific time point, sorted by the execution count, total time, and such. When the DB load increases, you can find which SQL queries are costing the most among those executed at the same time.

#### <Cmdname sid="BTN09458" className="uitext" />

You can sort the external HTTP calls in the <UI>HTTPC</UI> tab to view the top 30 lists. You can check if there is any bottleneck when there are many external APIs or internal HTTP requests.
