<!-- 스크린샷 최신화/상세화 필요-->

ホーム画面 > プロジェクト選択 > **_分析_** > **_スタック_**

WhaTapモニタリングサービスの初期画面でプロジェクトを選択し、**_プロジェクトメニュー_**下の**_分析_** > **_スタック_**を選択してください。**_トップスタック_**と**_ユニークスタック_**、**_アクティブスタック_**を確認することができます。 

:::note

スタック分析機能を使用できるアプリケーションは**Java**と**Python**、**.NET**です。 

:::

WhaTapは、10秒(デフォルト値) 間隔で収集したThread Stackを使用して、メソッドレベルの性能遅延を分析します。

<InDoc product='java,python'>

![st1](https://img.whatap.io/media/user_guide_application/stack/st1.png)

例）スタックの**トップライン**は`socketRead0`です。 

```java
java.net.SocketInputStream.socketRead0(Native Method)
```

</InDoc>

<InDoc product='dotnet'>

![dotnet active stack](/img/apm-analysis-stack-example-dotnet.png)

例）スタックの**トップライン**は`IL_STUB_ReversePInvoke `です。 

```c
DomainNeutralILStubClass.IL_STUB_ReversePInvoke(Int64,Int64,Int64,Int32)
```

</InDoc>

**トップライン**は、ダンプを実行するスレッドがメソッドを実行中であることを意味します。すぐにキャッチされる可能性もありますが、確率的にそのモジュールの処理時間のコンセンサスの比率をスタックに表示します。この**トップライン**メソッドを計算してメソッドレベルのパフォーマンスを判断することができます。WhaTapは、**トップライン頻度統計**を**_トップスタック_**(Top Stack)と呼びます。

<ImgLang img='apm-analysis-apm-top-stack-01.png' desc='トップスタック' />

**_トップスタック_**分析を使用したメソッドに対して、どのメソッドが呼び出しされた頻度を分析できます。

<ImgLang img='apm-analysis-apm-top-stack-02.png' desc='トップスタック' />

トップスタックの階層分析では、もともとのアクティブスタックを確認するのが困難でした。しかし、WhaTapは、**_アクティブスタック_**(Active Stack)を参照できるように同じスタックを集めて**_ユニークスタック_**(Unique Stack)と呼ばれる検索機能を提供します。

## **_トップスタック_**{#top-stack}

StackTraceの各Stepを基準に、StepとStep間の呼び出し比率をパーセンテージで分析した情報を提供します。最上位Stepのバックログ頻度をパーセンテージで算出し、降順に並べ替えられた結果を表示します。

各ステップをクリックすると、ステップを呼び出す上位ステップの呼び出し頻度をパーセンテージで算出して提供します。

**_トップスタック_**統計は十分なデータで
判断する必要があります。収集したスタックの数が10個未満の少数の場合、統計的な意味を持つには不十分です。

**_トップスタック_**はチューニング時に認識しづらい部分のチューニングポイントを見つけるのに役立ちます。最も頻繁に表示されるスタックは、アプリケーションサーバーでもっとも応答遅延が発生しているスタックであると判断できます。左端の割合は、アプリケーションサーバーのパフォーマンスに影響を与える程度です。

安定したアプリケーションサーバーであっても、頻繁なスタックはパフォーマンス低下を引き起こす可能性があるため、これらのクラスに注意深く監視することをお勧めします。

**_トップスタック_**をクリックすると、そのトップスタックを呼び出す頻度を確認できます。**_トップスタック_**の呼び出し関係は1対1の関係であるため、**_トップスタック_**のdepthの深さが下がるにつれて情報の精度が低下する可能性があります。下位depthに関する情報は参考として使用し、チューニングを進めてください。

アプリケーションのパフォーマンスを向上させるには、最上位Stepのバックログ比率が高いモジュールのボトルネックを調べる必要があります。バックログ比率が高いモジュールの場合、パフォーマンスが少し向上しただけでも、アプリケーション全体が大幅に改善される可能性があります。

<ImgLang img='apm-analysis-apm-top-stack-03.png' desc='トップスタック' />

```java {1,3}
whatap.util.ThreadUtil.sleep
// jdbc.Control.execの呼び出し比率は40.02%
jdbc.Control.exec
// // jdbc.FakePreparedStatement.executeQuery呼び出し比率は68.06%
```

`whatap.util.ThreadUtil.sleep` ← `jdbc.Control.exec` ← `jdbc.FakePreparedStatement.executeQuery`の呼び出し比率が 40.02% \* 68.06% を意味するものではありません。`jdbc.Control.exec`で他モジュールの呼び出す可能性があるためです。

**_トップスタック_**を使用して呼び出し比率を判断する場合、各Step間の呼び出し比率を掛け合わせて全体の呼び出し関係比率を算出してはいけません。Top Stackの呼び出し比率は、Stack Traceに表示される情報のStep間の呼び出し比率の算出した結果であるため、Step間の呼び出し比率から全体的な呼び出し比率を算出すると、歪んだ結果が得られる可能性があります。

**_トップスタック_**統計では、時間の経過に伴う比率の変化と収集件数を提供しますす。

<ImgLang img='apm-analysis-apm-top-stack-04.png' desc='トップスタック' />

-   **_パーセント_**

    -   検索期間を選択したトップスタックの比率の変化を示します。
    -   不具合箇所の状況把握や改善前後の比較に役立ちます。

-   **_件数_**

    -   収集されるスタックの数は、アクティブトランザクションの数に比例します。
    -   特定のセグメントで収集量が増加している場合は、サービスの遅延または急激な流入量の増加があったことが分かります。

次のようなダイヤグラムでも確認できます。

<ImgLang img='apm-analysis-apm-top-stack-05.png' desc='トップスタック' />

-   **_Stack Chart_**

    個々のトップスタックの比率をチャートで示します。

## **_ユニークスタック_**{#unique-stack}

Stack Trace全体のHash値基準の算出した結果、全体Stepが同じ呼び出し比率をパーセンテージで分析した情報を提供します。**_トップスタック_**は、Step間の呼び出し比率に関する情報を提供します。 

**_ユニークスタック_**は、Stack Trace全体の正確な呼び出し情報に基づいてデータを提供します。詳細な呼び出し関係を理解する情報を提供します。例えば、バックログ比率の高いStack Traceを特定することができます。

<ImgLang img='apm-analysis-apm-unique-stack.png' desc='ユニークスタック' />

詳細な呼び出しステップレビューにより、呼び出しパス上の異常なモジュールの存在を特定することができます。

## **_アクティブスタック_**{#active-stack}

進行中のトランザクションをアクティブトランザクションと呼びます。**アクティブトランザクションから定期的にダンプされるスタック**は**_アクティブスタック_**と呼ばれます。

:::note

WhaTapエージェントは、10秒(オプション)ごとに**アクティブトランザクション**から**_アクティブスタック_**をダンプし、サーバーに送信します。<br/>
`active_stack_second=10`

:::

**_アクティブスタック_**メニューを選択すると、収集されたActiveStackをチャートで確認できます。チャートは5分間の単位統計データを**_Active Transaction_**の数を棒グラフとして、**_TPS_**を折れ線で表示します。 

グラフ内の棒をクリックするとアクティブなトランザクションの情報が表示されます。アクティブトランザクションの情報をクリックするとトランザクションのアクティブスタックが表示されます。

<ImgLang img='apm-analysis-apm-active-stack.png' desc='アクティブスタック' />

:::note

アクティブトランザクションの詳細については、[次の文書](active-transactions)を参照してください。

:::

{@include: ../common-items/_compact-active-stacks.mdx}  

{@include: ../common-items/_background-thread.mdx} 

## 適用例

<!-- 스크린샷 수정 필요 -->

以下は、**_スタック_** > **_トップスタック_**メニューから特定の時間帯の履歴を検索する例です。トレースやトランザクション統計情報から見つけられない様々な改善要件を見つめることができます。

1.  **_スタック_** > **_トップスタック_**メニューからトップスタック情報を表示します。

    ![tst-view](https://img.whatap.io/media/images/Screenshot_2020-12-15_W_JAVA_DEMO_5490_-_Application_Monitoring31.png)

2.  シェア順に上位項目からClass／Method情報を確認してください。

    -   **最高** 79.92%比率を占めるトップスタック

        `org.apache.logging.log4j.core.layout.TextEncoderHelper.copyDataToDestination()`

    -   **2番目に高い** 8.01%比率を占めるトップスタック

        `sun.misc.Unsafe.park()` 

3.  ヒストリー機能で時間帯別の推移を確認できます。

    ![history](https://img.whatap.io/media/images/Screenshot_2020-12-15_W_JAVA_DEMO_5490_-_Application_Monitoring30.png)

    -   午前6時頃に、`TextEncoderHelper.copyDataToDestination()`の割合が低下したことを確認できます。
    -   同時に、`sun.misc.Unsafe.park`は`TextEncoderHelper.copyDataToDestination()`の割合を減らして増加した。

    上位1,2のトップスタックはすべてLoggingに関連しています。つまり、システムは全体の業務で90%に近くをLoggingに費やしていることが確認できます。

4.  確認した稼働率をもとに改善の期待効果を算定します。

    この例では、`copyDataToDestination()`79.92%、`sun.misc.Unsafe。park()`8.01%の割合はサービスの実行中に占有された時間の割合です。つまり、`copyDataToDestination()`のシェアを半分にすると、応答時間に関して44%ほどパフォーマンスを向上させることができます。

5.  トップスタック情報をもとに、改善方法を検討します。

    ```java title='org.apache.logging.log4j.core.layout.TextEncoderHelper.copyDataToDestination()'
    private static void copyDataToDestination(final ByteBuffer temp, final ByteBufferDestination destination) {
        synchronized (destination) {
            ByteBuffer destinationBuffer = destination.getByteBuffer();
            if (destinationBuffer != temp) { // still need to write to the destination
                temp.flip();
                if (temp.remaining() > destinationBuffer.remaining()) {
                    destinationBuffer = destination.drain(destinationBuffer);
                }
                destinationBuffer.put(temp);
                temp.clear();
            }
        }
    }
    ```

    -   `TextEncoderHelper`は性能問題など様々な理由でDeprecatedされたAPIです。

    -   `sun.misc.Unsafe.park()`は`TextEncoderHelper`内部のsynchronizedと関連があります。
